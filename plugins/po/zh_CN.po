# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
# Christopher Meng <cickumqt@gmail.com>, 2013
# Leah Liu <lliu@redhat.com>, 2008, 2009, 2010, 2012
# Tommy He <lovenemesis@gmail.com>, 2012-2013
# Tony Fu <tfu@redhat.com>, 2006
# Wei Liu <LLIU@REDHAT.COM>, 2013
# Xi Huang <xhuang@redhat.com>, 2006
# Leah Liu <lliu@redhat.com>, 2016. #zanata
# Tian Shixiong <tiansworld@fedoraproject.org>, 2016. #zanata
# Vit Mojzis <vmojzis@redhat.com>, 2017. #zanata
# cheng ye <18969068329@163.com>, 2017. #zanata
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-20 17:16+0100\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"PO-Revision-Date: 2017-11-08 05:31-0500\n"
"Last-Translator: Copied by Zanata <copied-by-zanata@zanata.org>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/projects/p/fedora/"
"language/zh_CN/)\n"
"Language: zh-CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Zanata 3.9.6\n"

#: ../src/allow_anon_write.py:27
msgid ""
"\n"
"    SELinux policy is preventing an httpd script from writing to a public\n"
"    directory.\n"
"    "
msgstr "\n"
"    SELinux 策略正在阻止 httpd 脚本在公共\n"
"    目录中写入内容。\n"
"    "

#: ../src/allow_anon_write.py:32
msgid ""
"\n"
"    SELinux policy is preventing an httpd script from writing to a public\n"
"    directory.  If httpd is not setup to write to public directories, this\n"
"    could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 策略正在阻止 httpd 脚本向公共目录写入内容。\n"
"    如果没有将 httpd 设置为可写入公共目录，这可能是尝试入侵的信号。\n"
"    "

#: ../src/allow_anon_write.py:38
msgid ""
"\n"
"    If httpd scripts should be allowed to write to public directories you "
"need to turn on the $BOOLEAN boolean and change the file context of the "
"public directory to public_content_rw_t.  Read the httpd_selinux\n"
"    man page for further information:\n"
"    \"setsebool -P $BOOLEAN=1; chcon -t public_content_rw_t <path>\"\n"
"    You must also change the default file context labeling files on the "
"system in order to preserve public directory labeling even on a full relabel."
"  \"semanage fcontext -a -t public_content_rw_t <path>\"\n"
"    "
msgstr ""
"\n"
"    如果应允许 httpd 脚本写入公共目录，则需要打开 $BOOLEAN 布尔值，并且将公共目录的文件环境改为 "
"public_content_rw_t。详情请查看阅读 httpd_selinux \n"
"    的 man page：\n"
"    \"setsebool -P $BOOLEAN=1; chcon -t public_content_rw_t <path>\"\n"
"    另外，还必须更改系统默认文件环境的标记文件，以便即使在完全重新标记时仍可保留公共目录的标记。 \"semanage fcontext -a -t "
"public_content_rw_t <path>\"\n"
"        "

#: ../src/allow_anon_write.py:44
msgid ""
"If you want to allow $SOURCE_PATH to be able to write to shared public "
"content"
msgstr "如果您想要允许 $SOURCE_PATH 拥有向共享公用内容写入的权限"

#: ../src/allow_anon_write.py:45
msgid ""
"you need to change the label on $TARGET_PATH to public_content_rw_t, and "
"potentially turn on the allow_httpd_sys_script_anon_write boolean."
msgstr ""
"您需要将 $TARGET_PATH 的标记改为 public_content_rw_t，可能还要再打开 "
"allow_httpd_sys_script_anon_write 布尔值。"

#: ../src/allow_execheap.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from changing the access\n"
"    protection of memory on the heap.\n"
"    "
msgstr "\n"
"    SELinux 将阻止 $SOURCE 修改堆上\n"
"    的内存 (memory on the heap) 访问保护。\n"
"    "

#: ../src/allow_execheap.py:32
msgid ""
"\n"
"    The $SOURCE application attempted to change the access protection of "
"memory on\n"
"    the heap (e.g., allocated using malloc).  This is a potential security\n"
"    problem.  Applications should not be doing this. Applications are\n"
"    sometimes coded incorrectly and request this permission.  The\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"Memory Protection Tests</a>\n"
"    web page explains how to remove this requirement.  If $SOURCE does not "
"work and\n"
"    you need it to work, you can configure SELinux temporarily to allow\n"
"    this access until the application is fixed. Please file a bug\n"
"    report against this package.\n"
"    "
msgstr ""
"\n"
"    $SOURCE 应用程序试图修改内存堆 (memory on the heap，\n"
"    比如使用 malloc 分配的内存) 的访问保护。这是潜在的安全问题。\n"
"    正常情况下应用程序不会有这样的行为，不过有时错误的代码也可能\n"
"    会请求此权限。<a href=\"http://people.redhat.com/drepper/selinux-mem."
"html\">SELinux 内存保护测试</a>页面介绍了删除此\n"
"    请求的方法。如果 $SOURCE 不能正常工作，但又需要它运行，\n"
"    则在此应用得到修正前可以配置 SELinux 临时允许此访问。\n"
"    请针对此软件包上报 bug。\n"
"    "

#: ../src/allow_execheap.py:44
msgid ""
"\n"
"    If you want $SOURCE to continue, you must turn on the\n"
"    $BOOLEAN boolean.  Note: This boolean will affect all applications\n"
"    on the system.\n"
"    "
msgstr ""
"\n"
"    如果想让 $SOURCE 继续执行, 必须将\n"
"    $BOOLEAN 布尔值设为开启。注意：该布尔值将会影响系统中的\n"
"    所有应用程序。 \n"
" "

#: ../src/allow_execheap.py:50
msgid ""
"If you do not think $SOURCE_PATH should need to map heap memory that is both "
"writable and executable."
msgstr ""

#: ../src/allow_execheap.py:51
msgid "you need to report a bug. This is a potentially dangerous access."
msgstr "应该报告 bug。此访问可能有危险。"

#: ../src/allow_execheap.py:52 ../src/allow_execstack.py:91
#: ../src/kernel_modules.py:46 ../src/mmap_zero.py:48
#: ../src/selinuxpolicy.py:46 ../src/setenforce.py:29 ../src/setenforce.py:50
#: ../src/sys_module.py:30 ../src/sys_module.py:48
msgid "Contact your security administrator and report this issue."
msgstr "联络安全管理员并报告此问题。"

#: ../src/allow_execmod.py:29
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from loading $TARGET_PATH which "
"requires text relocation.\n"
"    "
msgstr "\n"
"    SELinux 将阻止 $SOURCE 加载需要重新定位文本的 $TARGET_PATH。\n"
"    "

#: ../src/allow_execmod.py:33
msgid ""
"\n"
"    The $SOURCE application attempted to load $TARGET_PATH which\n"
"    requires text relocation.  This is a potential security problem.\n"
"    Most libraries do not need this permission. Libraries are\n"
"    sometimes coded incorrectly and request this permission.  The\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"Memory Protection Tests</a>\n"
"    web page explains how to remove this requirement.  You can configure\n"
"    SELinux temporarily to allow $TARGET_PATH to use relocation as a\n"
"    workaround, until the library is fixed. Please file a\n"
"bug report.\n"
"    "
msgstr ""
"\n"
"    $SOURCE 应用试图加载 $TARGET_PATH，这需要\n"
"    进行“文本迁移” (text relocation)。 这可能是个安全问题。\n"
"    大多数库并不需要此权限。有时库的代码可能存在错误\n"
"    才会请求此权限。<a href=\"http://people.redhat.com/drepper/selinux-mem."
"html\">SELinux 内存保护测试</a>\n"
"    网页介绍了删除此请求的方法。在有问题的库得到修复之前，\n"
"    您可将 SELinux 临时设置为允许 $TARGET_PATH 使用迁移。\n"
"    请提交 bug 报告。\n"
"    "

#: ../src/allow_execmod.py:45
msgid ""
"\n"
"    The $SOURCE application attempted to load $TARGET_PATH which\n"
"    requires text relocation.  This is a potential security problem.\n"
"    Most libraries should not need this permission.   The\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">\n"
"    SELinux Memory Protection Tests</a>\n"
"    web page explains this check.  This tool examined the library and it "
"looks\n"
"    like it was built correctly. So setroubleshoot can not determine if this\n"
"    application is compromised or not.  This could be a serious issue. Your\n"
"    system may very well be compromised.\n"
"\n"
"    Contact your security administrator and report this issue.\n"
"\n"
"    "
msgstr ""

#: ../src/allow_execmod.py:62
msgid ""
"\n"
"    If you trust $TARGET_PATH to run correctly, you can change the\n"
"    file context to textrel_shlib_t. \"chcon -t textrel_shlib_t\n"
"    '$TARGET_PATH'\"\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"textrel_shlib_t '$FIX_TARGET_PATH'\"\n"
"\n"
"    "
msgstr ""
"\n"
"    如果您确信 $TARGET_PATH 可正常运行，则可将文件环境 (context)\n"
"    改为 textrel_shlib_t。\"chcon -t textrel_shlib_t\n"
"    '$TARGET_PATH'\"\n"
"    您还必须修改系统中的默认文件环境文件，以便即使在完全重新标记 (relabel) 后也能保留它们。\"semanage fcontext -a -"
"t textrel_shlib_t '$FIX_TARGET_PATH'\"\n"
"\n"
"    "

#: ../src/allow_execstack.py:60
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from making the program stack "
"executable.\n"
"    "
msgstr "\n"
"    SELinux 将阻止 $SOURCE_PATH 使程序栈可执行。\n"
"    "

#: ../src/allow_execstack.py:64
msgid ""
"\n"
"    The $SOURCE application attempted to make its stack\n"
"    executable.  This is a potential security problem.  This should\n"
"    never ever be necessary. Stack memory is not executable on most\n"
"    OSes these days and this will not change. Executable stack memory\n"
"    is one of the biggest security problems. An execstack error might\n"
"    in fact be most likely raised by malicious code. Applications are\n"
"    sometimes coded incorrectly and request this permission.  The\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"Memory Protection Tests</a>\n"
"    web page explains how to remove this requirement.  If $SOURCE does not\n"
"    work and you need it to work, you can configure SELinux\n"
"    temporarily to allow this access until the application is fixed. Please\n"
"file a bug report.\n"
"    "
msgstr ""
"\n"
"    $SOURCE 应用尝试将其栈变成可执行。 这是个潜在的安全问题。 \n"
"    此行为没有任何必要。在当今多数操作系统中，栈内存都是不可执行\n"
"    的，并且在将来也不会有变化。栈内存可执行是最严重的安全问题\n"
"    之一。而造成此问题的最可能原因就是恶意代码。有时不正确的应用\n"
"    程序代码会请求此项权限。<a href=\"http://people.redhat.com/drepper/selinux-mem."
"html\">SELinux 内存保护测试</a>解释了\n"
"    如何移除此种请求。如果 $SOURCE 无法正常运行，但您需要让它\n"
"    正常运行，那么在此应用程序修正之前，可临时配置 SELinux 以允许\n"
"    此请求。欢迎提交 bug 报告。\n"
"    "

#: ../src/allow_execstack.py:79
msgid ""
"\n"
"    Sometimes a library is accidentally marked with the execstack flag,\n"
"    if you find a library with this flag you can clear it with the\n"
"    execstack -c LIBRARY_PATH.  Then retry your application.  If the\n"
"    app continues to not work, you can turn the flag back on with\n"
"    execstack -s LIBRARY_PATH.\n"
"    "
msgstr ""
"\n"
"    有时库文件会意外被标上 execstack 标记。如果您发现有\n"
"    库带有此标记，您可以使用命令 execstack -c LIBRARY_PATH \n"
"    将其清除。然后尝试重新应用程序。如果程序仍然无法运行，\n"
"    您可用 execstack -s LIBRARY_PATH 命令重新为库加上\n"
"    此标记。\n"
"    "

#: ../src/allow_execstack.py:89
msgid ""
"If you do not think $SOURCE_PATH should need to map stack memory that is "
"both writable and executable."
msgstr ""

#: ../src/allow_execstack.py:90
msgid "you need to report a bug. \n"
"This is a potentially dangerous access."
msgstr "需要报告这个 bug。\n"
"这可能是个潜在的危险访问。"

#: ../src/allow_execstack.py:99
#, python-format
msgid "If you believe that \n"
"%s\n"
"should not require execstack"
msgstr ""

#: ../src/allow_execstack.py:108
#, python-format
msgid ""
"you should clear the execstack flag and see if $SOURCE_PATH works correctly.\n"
"Report this as a bug on %s.\n"
"You can clear the exestack flag by executing:"
msgstr ""
"应该清除 execstack 标记，然后看 $SOURCE_PATH 是否可以正常工作。\n"
"将其作为 %s 中的 bug 报告。\n"
"可以执行以下命令清除 execstack 标记："

#: ../src/allow_execstack.py:118
#, python-format
msgid "execstack -c %s"
msgstr "execstack -c %s"

#: ../src/allow_ftpd_use_cifs.py:29
msgid ""
"\n"
"    SELinux prevented the ftp daemon from $ACCESS files stored on a CIFS "
"filesystem.\n"
"    "
msgstr "\n"
"    SELinux 已阻止 ftp 守护进程 $ACCESS 保存在 CIFS 文件系统中的文件。\n"
"    "

#: ../src/allow_ftpd_use_cifs.py:33
msgid ""
"\n"
"    SELinux prevented the ftp daemon from $ACCESS files stored on a CIFS "
"filesystem.\n"
"    CIFS (Comment Internet File System) is a network filesystem similar to\n"
"    SMB (<a href=\"http://www.microsoft.com/mind/1196/cifs.asp\">http://www."
"microsoft.com/mind/1196/cifs.asp</a>)\n"
"    The ftp daemon attempted to read one or more files or directories from\n"
"    a mounted filesystem of this type.  As CIFS filesystems do not support\n"
"    fine-grained SELinux labeling, all files and directories in the\n"
"    filesystem will have the same security context.\n"
"\n"
"    If you have not configured the ftp daemon to read files from a CIFS "
"filesystem\n"
"    this access attempt could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了 ftp 守护进程 $ACCESS 保存在 CIFS 文件系统中的文件。\n"
"    CIFS (Comment Internet File System) 是类似于 SMB (<a href=\"http://www."
"microsoft.com/mind/1196/cifs.asp\">http://www.microsoft.com/mind/1196/cifs."
"asp</a>) 的文件系统。\n"
"    ftp 守护进程尝试从已挂载的此类文件系统中读取一个或多个文件或目录。\n"
"    因 CIFS 文件系统不支持精细的 SELinux 标签，因此文件系统中的所有文件\n"
"    和目录拥有相同的安全环境 (security context)。\n"
"\n"
"    如果并未将让 ftp 守护进程配置为读取位于 CIFS 文件系统的文件，那么这样\n"
"    的尝试很有可能是入侵的信号。\n"
"    "

#: ../src/allow_ftpd_use_cifs.py:46
msgid ""
"\n"
"    Changing the \"$BOOLEAN\" boolean to true will allow this access:\n"
"    \"setsebool -P $BOOLEAN=1.\"\n"
"    "
msgstr ""
"\n"
"    将 \"$BOOLEAN\" 布尔值修改为“true”即可允许本访问：\n"
"    \"setsebool -P $BOOLEAN=1.\"\n"
"    "

#: ../src/allow_ftpd_use_cifs.py:53
msgid ""
" Changing the \"$BOOLEAN\" and\n"
"    \"$WRITE_BOOLEAN\" booleans to true will allow this access:\n"
"    \"setsebool -P $BOOLEAN=1 $WRITE_BOOLEAN=1\".\n"
"    warning: setting the \"$WRITE_BOOLEAN\" boolean to true will\n"
"    allow the ftp daemon to write to all public content (files and\n"
"    directories with type public_content_t) in addition to writing to\n"
"    files and directories on CIFS filesystems.  "
msgstr ""
" 修改 \"$BOOLEAN\" 和 \n"
"    \"$WRITE_BOOLEAN\" 布尔值为“true”将允许这个访问：\n"
"    \"setsebool -P $BOOLEAN=1 $WRITE_BOOLEAN=1\"。\n"
"    警告：设置 \"$WRITE_BOOLEAN\"布尔值为“true”以后，除允许\n"
"    ftp守护进程向 CIFS 文件系统上的文件和目录写入外，还将\n"
"    允许其向所有的公共内容 (类型为 public_content_t 的文件和目录) 写入。"

#: ../src/allow_ftpd_use_cifs.py:62
msgid "If you want to allow ftpd to write to cifs file systems"
msgstr ""

#: ../src/allow_ftpd_use_cifs.py:63 ../src/allow_ftpd_use_nfs.py:65
msgid "you must tell SELinux about this"
msgstr "必须告知 SELinux 这一情况"

#: ../src/allow_ftpd_use_nfs.py:29
msgid ""
"\n"
"    SELinux prevented the ftp daemon from $ACCESS files stored on a NFS "
"filesystem.\n"
"    "
msgstr "\n"
"    SELinux 阻止了 ftp 守护进程 $ACCESS 保存在 NFS 文件系统中的文件。\n"
"    "

#: ../src/allow_ftpd_use_nfs.py:33
msgid ""
"\n"
"    SELinux prevented the ftp daemon from $ACCESS files stored on a NFS "
"filesystem.\n"
"    NFS (Network Filesystem) is a network filesystem commonly used on Unix / "
"Linux\n"
"    systems.\n"
"\n"
"    The ftp daemon attempted to read one or more files or directories from\n"
"    a mounted filesystem of this type.  As NFS filesystems do not support\n"
"    fine-grained SELinux labeling, all files and directories in the\n"
"    filesystem will have the same security context.\n"
"\n"
"    If you have not configured the ftp daemon to read files from a NFS "
"filesystem\n"
"    this access attempt could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了 ftp 守护进程 $ACCESS 保存在 NFS 文件系统中的文件。\n"
"    NFS (Network Filesystem) 是广泛用于 Unix 及 Linux 的网络文件系统。\n"
"\n"
"    ftp 守护进程尝试从已挂载的此类文件系统中读取一个或多个文件或目录。\n"
"    因 NFS 文件系统不支持精细的 SELinux 标记，因此文件系统中的所有文件\n"
"    和目录拥有相同的安全环境 (security context)。\n"
"\n"
"    如果并未将 ftp 守护进程配置为读取位于 NFS 文件系统中的文件，那么这样\n"
"    的尝试很有可能是入侵的信号。\n"
"    "

#: ../src/allow_ftpd_use_nfs.py:47
msgid ""
"\n"
"    Changing the \"allow_ftpd_use_nfs\" boolean to true will allow this "
"access:\n"
"    \"setsebool -P allow_ftpd_use_nfs=1.\"\n"
"    "
msgstr ""
"\n"
"    将 \"allow_ftpd_use_nfs\" 的布尔值改为“true”可允许此访问：\n"
"    \"setsebool -P allow_ftpd_use_nfs=1.\"\n"
"    "

#: ../src/allow_ftpd_use_nfs.py:54
msgid ""
" Changing the \"allow_ftpd_use_nfs\" and\n"
"    \"$WRITE_BOOLEAN\" booleans to true will allow this access:\n"
"    \"setsebool -P allow_ftpd_use_nfs=1 $WRITE_BOOLEAN=1\".\n"
"    warning: setting the \"$WRITE_BOOLEAN\" boolean to true will\n"
"    allow the ftp daemon to write to all public content (files and\n"
"    directories with type public_content_t) in addition to writing to\n"
"    files and directories on NFS filesystems.  "
msgstr ""
" 修改 \"allow_ftpd_use_nfs\" 和\n"
"    \"$WRITE_BOOLEAN\"布尔值为“true”将允许此访问：\n"
"    \"setsebool -P allow_ftpd_use_nfs=1$WRITE_BOOLEAN=1\"。\n"
"    警告：设置\"$WRITE_BOOLEAN\"布尔值为“true”后，除了允许 ftp 守护进程\n"
"    向 NFS 文件系统中的文件和目录写入外，还将\n"
"    允许向所有公共内容 (类型为 public_content_t 的文件和目录) 写入。"

#: ../src/allow_ftpd_use_nfs.py:64
msgid "If you want to allow ftpd to write to nfs file systems"
msgstr ""

#: ../src/associate.py:32 ../src/openvpn.py:31 ../src/public_content.py:27
#: ../src/qemu_blk_image.py:27 ../src/qemu_file_image.py:27
#: ../src/restorecon.py:51 ../src/restorecon_source.py:33
#: ../src/rsync_data.py:27 ../src/sshd_root.py:32
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH \"$ACCESS\" access to $TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 将阻止 $SOURCE_PATH \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    "

#: ../src/associate.py:37
#, python-format
msgid ""
"\n"
"You tried to place a type on a %s that is not a file type.  This is not "
"allowed, you must assigne a file type.  You can list all file types using "
"the seinfo command.\n"
"\n"
"seinfo -afile_type -x\n"
"\n"
"    "
msgstr ""
"\n"
"尝试在 %s 设定的类型不是文件类型。  这是不允许的，必须指定文件类型。  可以使用 seinfo 命令列出所有文件类型。\n"
"\n"
"seinfo -afile_type -x\n"
"\n"
"    "

#: ../src/associate.py:44
#, python-format
msgid ""
"If you want to change the label of $TARGET_PATH to %s, you are not allowed "
"to since it is not a valid file type."
msgstr ""

#: ../src/associate.py:49
msgid "you must pick a valid file label."
msgstr "必须挑选有效文件标记。"

#: ../src/automount_exec_config.py:27
msgid ""
"\n"
"    SELinux is preventing the $SOURCE_PATH from executing potentially "
"mislabeled files $TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH 执行可能错误标记的文件 $TARGET_PATH 。\n"
"    "

#: ../src/automount_exec_config.py:31
msgid ""
"\n"
"    SELinux has denied the $SOURCE_PATH from executing potentially\n"
"    mislabeled files $TARGET_PATH.  Automounter can be setup to execute\n"
"    configuration files. If $TARGET_PATH is an automount executable\n"
"    configuration file it needs to have a file label of bin_t.\n"
"    If automounter is trying to execute something that it is not supposed "
"to, this could indicate an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"  SELinux 已经拒绝 $SOURCE_PATH 执行可能错\n"
"  误标记的文件 $TARGET_PATH。可将 automounter 设置为\n"
"  执行配置文件，如果 $TARGET_PATH 是一个自动挂载可执行\n"
"  配置文件，则需要有一个 bin_t 文件标记。\n"
"  如果 automounter 正在试图执行它不应该执行的动作， 则可能是一个入侵攻击提示。\n"
" "

#: ../src/automount_exec_config.py:39
msgid ""
"\n"
"    If you want to change the file context of $TARGET_PATH so that the "
"automounter can execute it you can execute \"chcon -t bin_t $TARGET_PATH\".  "
"If you want this to survive a relabel, you need to permanently change the "
"file context: execute  \"semanage fcontext -a -t bin_t '$FIX_TARGET_PATH'\".\n"
"    "
msgstr ""
"\n"
"    如果要更改 $TARGET_PATH 的文件上下文以便自动挂载程序可执行它，则可执行 \"chcon -t bin_t "
"$TARGET_PATH\"。如果要在重新标记后仍保留它，则需要永久更改文件上下文： 请执行  \"semanage fcontext -a -t "
"bin_t '$FIX_TARGET_PATH'\"。\n"
"    "

#: ../src/bind_ports.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from binding to port $PORT_NUMBER.\n"
"    "
msgstr "\n"
"    SELinux 将阻止 $SOURCE 绑定到端口 $PORT_NUMBER。\n"
"    "

#: ../src/bind_ports.py:31
#, python-format
msgid ""
"\n"
"    SELinux has denied the $SOURCE from binding to a network port "
"$PORT_NUMBER which does not have an SELinux type associated with it.\n"
"    If $SOURCE should be allowed to listen on $PORT_NUMBER, use the "
"<i>semanage</i> command to assign $PORT_NUMBER to a port type that "
"$SOURCE_TYPE can bind to (%s).\n"
"    \n"
"\n"
"If $SOURCE is not supposed\n"
"    to bind to $PORT_NUMBER, this could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 已拒绝 $SOURCE 绑定网络端口 $PORT_NUMBER，没有 SELinux 类型与之关联。\n"
"    如果应允许 $SOURCE 侦听 $PORT_NUMBER 端口，则可使用 <i>semanage</i> 命令将 $PORT_NUMBER "
"端口指定为 $SOURCE_TYPE 可绑定的端口类型 (%s)。\n"
"    \n"
"\n"
"如果 $SOURCE 不应绑定到 $PORT_NUMBER 端口，那么这可能是企图入侵的信号。\n"
"    "

#: ../src/bind_ports.py:38
#, python-format
msgid ""
"\n"
"    If you want to allow $SOURCE to bind to port $PORT_NUMBER, you can "
"execute \n"
"\n"
"    # semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"    \n"
"where PORT_TYPE is one of the following: %s.\n"
"\n"
"    \n"
"\n"
"If this system is running as an NIS Client, turning on the allow_ypbind "
"boolean may fix the problem.  setsebool -P allow_ypbind=1.\n"
"    "
msgstr ""
"\n"
"    如果要允许 $SOURCE 捆绑到端口 $PORT_NUMBER，可以执行\n"
"\n"
"    # semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"    \n"
"其中 PORT_TYPE 是以下之一：%s。\n"
"\n"
"    \n"
"\n"
"如果这个系统是作为 NIS 客户端运行，打开 allow_ypbind 布尔值可纠正这个问题。setsebool -P allow_ypbind=1。\n"
"    "

#: ../src/bind_ports.py:47
msgid "If you want to allow $SOURCE_PATH to bind to network port $PORT_NUMBER"
msgstr ""

#: ../src/bind_ports.py:53 ../src/connect_ports.py:51
#, python-format
msgid ""
"# semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"    where PORT_TYPE is one of the following: %s."
msgstr ""
"# semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"    其中 PORT_TYPE 是以下之一：%s。"

#: ../src/bind_ports.py:56 ../src/connect_ports.py:54
#, python-format
msgid "# semanage port -a -t %s -p %s $PORT_NUMBER"
msgstr "# semanage port -a -t %s -p %s $PORT_NUMBER"

#: ../src/catchall_boolean.py:32
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH \"$ACCESS\" access on $TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 将阻止 $SOURCE \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    "

#: ../src/catchall_boolean.py:36
msgid ""
"\n"
"\n"
"    SELinux denied access requested by $SOURCE. The current boolean\n"
"    settings do not allow this access.  If you have not setup $SOURCE to\n"
"    require this access this may signal an intrusion attempt. If you do "
"intend\n"
"    this access you need to change the booleans on this system to allow\n"
"    the access.\n"
"    "
msgstr ""
"\n"
"\n"
"    SELinux 拒绝了由 $SOURCE 发起的访问请求。当前布尔值设置不允许此访问。\n"
"    如果未设置 $SOURCE 请求此访问，那么这可能是企图入侵的信号。\n"
"    如果确实需要此访问权限，则需要将此系统上的布尔值修改为允许访问。\n"
"   "

#: ../src/catchall_boolean.py:45
msgid ""
"\n"
"    Confined processes can be configured to run requiring different access, "
"SELinux provides booleans to allow you to turn on/off\n"
"    access as needed.\n"
"\n"
"    "
msgstr ""
"\n"
"    受限制的进程可以配置为需要在不同访问权限下运行， SELinux 提供布尔值以便允许您根据需要打开或关闭 \n"
"    访问权限。\n"
"\n"
"    "

#: ../src/catchall_boolean.py:62
#, python-format
msgid "If you want to %s"
msgstr ""

#: ../src/catchall_boolean.py:65
#, python-format
msgid "setsebool -P %s %s"
msgstr "setsebool -P %s %s"

#: ../src/catchall_boolean.py:68
#, python-format
msgid "You must tell SELinux about this by enabling the '%s' boolean.\n"
msgstr "必须启用 '%s' 布尔值告知 SELinux 此情况。\n"

#: ../src/catchall_boolean.py:71
#, python-format
msgid "You can read '%s' man page for more details."
msgstr "可以阅读 '%s' 手册页面来了解详情。"

#: ../src/catchall_labels.py:28
#, python-format
msgid ""
"\n"
"    SELinux has denied the $SOURCE access to potentially\n"
"    mislabeled files $TARGET_PATH.  This means that SELinux will not\n"
"    allow httpd to use these files. If httpd should be allowed this access "
"to these files you should change the file context to one of the following "
"types, %s.\n"
"    Many third party apps install html files\n"
"    in directories that SELinux policy cannot predict.  These directories\n"
"    have to be labeled with a file context which httpd can access.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 对可能错误标记文件 $TARGET_PATH  \n"
"    的访问。这意味着 SELinux 将不允许 httpd 使用这些文件。如果应该允许 httpd \n"
"    访问这些文件，那么您应该将该文件的上下文更改为以下类型 %s。\n"
"    许多第三方应用程\n"
"    序将 html 文件安装在 SELinux 策略无法预知的目录。这些目录必须以一个 \n"
"    httpd 能访问的文件上下文被标记。\n"
"    "

#: ../src/catchall_labels.py:37
msgid "You need to change the label on $FIX_TARGET_PATH"
msgstr "必须更改 $FIX_TARGET_PATH 中的标签"

#: ../src/catchall_labels.py:40
#, python-format
msgid ""
"# semanage fcontext -a -t FILE_TYPE '$FIX_TARGET_PATH'\n"
"where FILE_TYPE is one of the following: %s.\n"
"Then execute:\n"
"restorecon -v '$FIX_TARGET_PATH'\n"
msgstr ""
"# semanage fcontext -a -t FILE_TYPE '$FIX_TARGET_PATH'\n"
"其中 FILE_TYPE 为以下内容之一：%s。\n"
"然后执行：\n"
"restorecon -v '$FIX_TARGET_PATH'\n"

#: ../src/catchall.py:29 ../src/chrome.py:29 ../src/mozplugger.py:29
#: ../src/mozplugger_remove.py:29
msgid "SELinux is preventing $SOURCE_PATH \"$ACCESS\" access."
msgstr "SELinux 防止 $SOURCE_PATH \"$ACCESS\" 访问。"

#: ../src/catchall.py:31
msgid ""
"\n"
"\n"
"    SELinux denied access requested by $SOURCE. It is not\n"
"    expected that this access is required by $SOURCE and this access\n"
"    may signal an intrusion attempt. It is also possible that the specific\n"
"    version or configuration of the application is causing it to require\n"
"    additional access.\n"
"\n"
"    "
msgstr ""
"\n"
"\n"
"    SELinux 拒绝了 $SOURCE 的访问请求。\n"
"    $SOURCE 并不应请求这种访问，它可能是尝试入侵的一\n"
"    个信号。也可能是应用程序的特别版本或配置导致它请求额外的访问。\n"
"\n"
"    "

#: ../src/catchall.py:41
msgid ""
"\n"
"    You can generate a local policy module to allow this\n"
"    access - see <a href=\"http://docs.fedoraproject.org/selinux-faq-fc5/"
"#id2961385\">FAQ</a>\n"
"\n"
"    Please file a bug report.\n"
"    "
msgstr ""
"\n"
"    可以创建本地策略模块，使用该模块允许这个\n"
"    访问 - 请查看 <a href=\"http://docs.fedoraproject.org/selinux-faq-fc5/"
"#id2961385\">常见问题</a>\n"
"    请提交 bug 报告。\n"
"    "

#: ../src/catchall.py:50
msgid ""
"If you believe that $SOURCE_BASE_PATH should be allowed $ACCESS access on "
"processes labeled $TARGET_TYPE by default."
msgstr ""

#: ../src/catchall.py:52
msgid ""
"If you believe that $SOURCE_BASE_PATH should have the $ACCESS capability by "
"default."
msgstr ""

#: ../src/catchall.py:53
msgid ""
"If you believe that $SOURCE_BASE_PATH should be allowed $ACCESS access on "
"the $TARGET_BASE_PATH $TARGET_CLASS by default."
msgstr ""

#: ../src/catchall.py:55
msgid ""
"You should report this as a bug.\n"
"You can generate a local policy module to allow this access."
msgstr "应该将这个情况作为 bug 报告。\n"
"可以生成本地策略模块以允许此访问。"

#: ../src/catchall.py:56
msgid ""
"Allow this access for now by executing:\n"
"# ausearch -c '$SOURCE' --raw | audit2allow -M my-$MODULE_NAME\n"
"# semodule -i my-$MODULE_NAME.pp"
msgstr ""

#: ../src/connect_ports.py:27 ../src/sandbox_connect.py:29
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from connecting to port $PORT_NUMBER.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH 连接到端口 $PORT_NUMBER。\n"
"    "

#: ../src/connect_ports.py:31
#, python-format
msgid ""
"\n"
"    SELinux has denied $SOURCE from connecting to a network port "
"$PORT_NUMBER which does not have an SELinux type associated with it.\n"
"    If $SOURCE should be allowed to connect on $PORT_NUMBER, use the "
"<i>semanage</i> command to assign $PORT_NUMBER to a port type that "
"$SOURCE_TYPE can connect to (%s).\n"
"    \n"
"\n"
"If $SOURCE is not supposed\n"
"    to connect to $PORT_NUMBER, this could signal an intrusion attempt.\n"
"    "
msgstr ""

#: ../src/connect_ports.py:38
#, python-format
msgid ""
"\n"
"    If you want to allow $SOURCE to connect to $PORT_NUMBER, you can execute "
"\n"
"\n"
"    # semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"\n"
"    where PORT_TYPE is one of the following: %s.\n"
"    "
msgstr ""
"\n"
"    如果要允许 $SOURCE 连接到 $PORT_NUMBER，可执行 \n"
"\n"
"    # semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"\n"
"    其中 PORT_TYPE 是以下之一：%s。\n"
"    "

#: ../src/connect_ports.py:45 ../src/sandbox_connect.py:47
msgid ""
"If you want to allow $SOURCE_PATH to connect to network port $PORT_NUMBER"
msgstr ""

#: ../src/chrome.py:31
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. It is not expected that this "
"access is required by $SOURCE and this access may signal an intrusion "
"attempt. It is also possible that the specific version or configuration of "
"the application is causing it to require additional access.  spice-xpi run "
"applications within mozilla-plugins that require access to the desktop, that "
"the mozilla_plugin lockdown will not allow, so either you need to turn off "
"the mozilla_plugin lockdown or not use these packages.\n"
"    "
msgstr ""
"\n"
"SELinux 拒绝了 $SOURCE 的访问请求。这不该是 $SOURCE 所需要的访问请求，因此该请求可能是尝试入侵的信号。 "
"当然这也可能是应用程序的特定版本或配置导致其需要额外的访问权限。spice-xpi 在需要访问桌面的 mozilla 插件中运行程序，而 "
"mozilla_plugin lockdown 不允许此操作，因此您只能关闭 mozilla 插件锁定功能，或者不使用这些软件包。"

#: ../src/chrome.py:35
msgid ""
"\n"
"Either remove the mozplugger or spice-xpi package by executing 'yum remove "
"mozplugger spice-xpi', or turn off enforcement of SELinux over the Chrome "
"plugins. setsebool -P unconfined_chrome_sandbox_transition 0\n"
"    "
msgstr ""
"\n"
"可通过 'yum remove mozplugger' 移除 mozplluger 或者 spice-xpi 软件包，或者关闭 Chrome 插件的 "
"SELinux 增强功能。\n"
"setsebool -P unconfined_chrome_sandbox_transition 0\n"
"   "

#: ../src/chrome.py:38 ../src/mozplugger.py:38
#, python-format
msgid "If you want to use the %s package"
msgstr ""

#: ../src/chrome.py:43
msgid "you must turn off SELinux controls on the Chrome plugins."
msgstr "则必须关闭 SELinux 对于 Chrome 插件的控制。"

#: ../src/cvs_data.py:27
msgid ""
"\n"
"    SELinux is preventing cvs ($SOURCE_PATH) \"$ACCESS\" access to "
"$TARGET_PATH\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 cvs ($SOURCE_PATH) \"$ACCESS\" 访问设备 $TARGET_PATH\n"
"    "

#: ../src/cvs_data.py:31
msgid ""
"\n"
"    SELinux denied cvs access to $TARGET_PATH.\n"
"    If this is a CVS repository it needs to have a file context label of\n"
"    cvs_data_t. If you did not intend to use $TARGET_PATH as a CVS "
"repository\n"
"    it could indicate either a bug or it could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了cvs 访问 $TARGET_PATH。\n"
"    如果这是一个 CVS 程序库，它应具有文件环境标记 cvs_data_t。\n"
"    如果您并没有打算将 $TARGET_PATH 作为 CVS 程序库使用，这可能是\n"
"    一个 bug 或是尝试入侵的信号。   \n"
" "

#: ../src/cvs_data.py:38
msgid ""
"\n"
"    You can alter the file context by executing chcon -R -t cvs_data_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"cvs_data_t '$FIX_TARGET_PATH'\"\n"
"    \n"
"    "
msgstr ""
"\n"
"    可以通过执行 chcon -R -t cvs_data_t '$TARGET_PATH' 修改文件环境。\n"
"    还必须修改系统的默认文件环境文件以便即使在完全重新标记后还可以保留它们。\"semanage fcontext -a -t vcs_data_t "
"'$FIX_TARGET_PATH'\"\n"
"    \n"
" "

#: ../src/cvs_data.py:44
msgid "If $TARGET_BASE_PATH should be shared via the cvs daemon"
msgstr ""

#: ../src/cvs_data.py:45 ../src/qemu_file_image.py:49
msgid "You need to change the label on $TARGET_BASE_PATH'"
msgstr "需要更改 $TARGET_BASE_PATH' 中的标签"

#: ../src/dac_override.py:28
msgid "\n"
"    SELinux is preventing $SOURCE_PATH the \"$ACCESS\" capability.\n"
"    "
msgstr "\n"
"    SELinux 会阻止 $SOURCE_PATH 的 \"$ACCESS\" 功能。\n"
"    "

#: ../src/dac_override.py:32
msgid ""
"\n"
"\tdac_override and dac_read_search capabilities usually indicates that the "
"root process does not have access to a file based on the permission flags.  "
"This usually mean you have some file with the wrong ownership/permissions on "
"it.\n"
"    "
msgstr ""
"\n"
"\tdac_override 和 dac_read_search 功能通常说明，鉴于权限标签，root "
"进程在无法访问某个文件。这通常意味着有些文件的所有者/权限是错误的。\n"
"    "

#: ../src/dac_override.py:38
msgid ""
"If you want to help identify if domain needs this access or you have a file "
"with the wrong permissions on your system"
msgstr ""

#: ../src/dac_override.py:39
msgid ""
"turn on full auditing to get path information about the offending file and "
"generate the error again."
msgstr "打开全面审核以获得有关违规文件路径信息并再次生成该错误。"

#: ../src/dac_override.py:40
msgid ""
"\n"
"Turn on full auditing\n"
"# auditctl -w /etc/shadow -p w\n"
"Try to recreate AVC. Then execute\n"
"# ausearch -m avc -ts recent\n"
"If you see PATH record check ownership/permissions on file, and fix it,\n"
"otherwise report as a bugzilla."
msgstr ""
"\n"
"开启完整审核\n"
"# auditctl -w /etc/shadow -p w\n"
"尝试重新生成 AVC。然后执行\n"
"# ausearch -m avc -ts recent\n"
"如果可看到 PATH 记录，检查文件的所有权及权限，然后修复。\n"
"否则需向 bugzila 提交报告。"

#: ../src/device.py:29
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH \"$ACCESS\" access to device "
"$TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH \"$ACCESS\" 访问设备 $TARGET_PATH.\n"
"    "

#: ../src/device.py:33
msgid ""
"\n"
"\n"
"    SELinux has denied $SOURCE \"$ACCESS\" access to device $TARGET_PATH.\n"
"    $TARGET_PATH is mislabeled, this device has the default label of the /"
"dev directory, which should not\n"
"    happen.  All Character and/or Block Devices should have a label.\n"
"\n"
"    You can attempt to change the label of the file using\n"
"\n"
"    restorecon -v '$TARGET_PATH'.\n"
"\n"
"    If this device remains labeled device_t, then this is a bug in SELinux "
"policy.\n"
"\n"
"    Please file a bg report.\n"
"\n"
"    If you look at the other similar devices labels, ls -lZ /dev/SIMILAR, "
"and find a type that would work for $TARGET_PATH,\n"
"    you can use chcon -t SIMILAR_TYPE '$TARGET_PATH', If this fixes the "
"problem, you can make this permanent by executing\n"
"    semanage fcontext -a -t SIMILAR_TYPE '$FIX_TARGET_PATH'\n"
"\n"
"    If the restorecon changes the context, this indicates that the "
"application that created the device, created it without\n"
"    using SELinux APIs.  If you can figure out which application created the "
"device, please file a bug report against this application.\n"
"\n"
"    "
msgstr ""
"\n"
"\n"
"    SELinux 已拒绝 $SOURCE \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    $TARGET_PATH 被错误标记，该设备拥有了 /dev 目录的默认标记，而这本不应该如此。\n"
"    所有特征 (character) 及/或块设备均应该拥有标记。\n"
"\n"
"    可使用以下命令修改文件的标记\n"
"\n"
"    restorecon -v '$TARGET_PATH'.\n"
"\n"
"    若此设备仍被标记为 device_t，那么这应该是 SELinux 策略的一个 bug。\n"
"\n"
"    请上报 bug。\n"
"\n"
"    如果使用 ls -lZ /dev/SIMILAR 看看其它类似设备的标记，则可以找到适用于 $TARGET_PATH 的类型。\n"
"    可使用命令 chcon -t SIMILAR_TYPE '$TARGET_PATH'，如果问题得到解决，则可使用以下命令将其永久更改。\n"
"    semanage fcontext -a -t SIMILAR_TYPE '$FIX_TARGET_PATH'\n"
"\n"
"     如果 restorecon 命令修改了环境，则表明创建该设备的应用未使用 SELinux 的 API 对其进行创建。\n"
"    如果可以查出是哪个应用创建了该设备，则可针对该应用程序提交 bug 报告。\n"
"\n"
"    "

#: ../src/device.py:56
msgid ""
"\n"
"    Attempt restorecon -v '$TARGET_PATH' or chcon -t SIMILAR_TYPE "
"'$TARGET_PATH'\n"
"    "
msgstr ""
"\n"
"    尝试 restorecon -v '$TARGET_PATH' 或 chcon -t SIMILAR_TYPE '$TARGET_PATH'\n"
"    "

#: ../src/device.py:60
msgid ""
"You need to change the label on $TARGET_PATH to a type of a similar device."
msgstr "需要将 $TARGET_PATH 的标签改为类似设备类型。"

#: ../src/device.py:61
msgid ""
"# semanage fcontext -a -t SIMILAR_TYPE '$FIX_TARGET_PATH'\n"
"# restorecon -v '$FIX_TARGET_PATH'"
msgstr ""
"# semanage fcontext -a -t SIMILAR_TYPE '$FIX_TARGET_PATH'\n"
"# restorecon -v '$FIX_TARGET_PATH'"

#: ../src/disable_ipv6.py:30
msgid "\n"
"Disable IPV6 properly.\n"
"    "
msgstr "\n"
"正确禁用 IPV6。\n"
"    "

#: ../src/disable_ipv6.py:40
msgid "If you want to disable IPV6 on this machine"
msgstr ""

#: ../src/disable_ipv6.py:41
msgid ""
"you need to set /proc/sys/net/ipv6/conf/all/disable_ipv6 to 1 and do not "
"blacklist the module'"
msgstr "则需要将 /proc/sys/net/ipv6/conf/all/disable_ipv6 设定为 1，且不要将该模块放入黑名单"

#: ../src/disable_ipv6.py:42
msgid "Add \n"
"net.ipv6.conf.all.disable_ipv6 = 1\n"
"to /etc/sysctl.conf\n"
msgstr "在 \n"
"/etc/sysctl.conf 中\n"
"添加 net.ipv6.conf.all.disable_ipv6 = 1\n"

#: ../src/file.py:27
msgid ""
"\n"
"    SELinux is preventing access to files with the label, file_t.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止访问带有 file_t 标记的文件。\n"
"    "

#: ../src/file.py:31
msgid ""
"\n"
"    SELinux permission checks on files labeled file_t are being\n"
"    denied.  file_t is the context the SELinux kernel gives to files\n"
"    that do not have a label. This indicates a serious labeling\n"
"    problem. No files on an SELinux box should ever be labeled file_t.\n"
"    If you have just added a disk drive to the system you can\n"
"    relabel it using the restorecon command.  For example if you saved the\n"
"home directory from a previous installation that did not use SELinux, "
"'restorecon -R -v /home' will fix the labels.  Otherwise you should\n"
"    relabel the entire file system.\n"
"    "
msgstr ""
"\n"
"    SELinux 权限对标记为 file_t 的文件进行检查\n"
"    遭到拒绝。file_t 是 SELinux 内核赋予无标记\n"
"    文件的文件环境。 这表明存在严重的标记\n"
"    问题。 在 SELinux 机器上不该有标记为 file_t 的文件。\n"
"    如果刚为系统添加了一个硬盘驱动器，您可\n"
"    用 restorecon 命令对其重新标记。举例来说，如果您保留了先前未使用 SELinux 的系统 home 目录，使用 "
"'restorecon -R -v /home' 可修复标记。否则您应该\n"
"    重新标记整个文件系统。\n"
"    "

#: ../src/file.py:42
msgid ""
"\n"
"    You can execute the following command as root to relabel your\n"
"    computer system: \"touch /.autorelabel; reboot\"\n"
"    "
msgstr ""
"\n"
"    可以作为 root 执行以下命令重新设置您计算机系统的标签：\n"
"    \"touch /.autorelabel; reboot\"\n"
"    "

#: ../src/file.py:49
msgid "This is caused by a newly created file system."
msgstr ""

#: ../src/file.py:51
msgid "If you think this is caused by a badly mislabeled machine."
msgstr ""

#: ../src/file.py:55
msgid "you need to add labels to it."
msgstr "您需要在其中添加标签。"

#: ../src/file.py:57
msgid "you need to fully relabel."
msgstr "需要全部重新标记。"

#: ../src/filesystem_associate.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from creating a file with a context "
"of $SOURCE_TYPE on a filesystem.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH 在文件系统中生成一个上下文为 $SOURCE_TYPE 的文件。\n"
"    "

#: ../src/filesystem_associate.py:31
msgid ""
"\n"
"    SELinux is preventing $SOURCE from creating a file with a context of "
"$SOURCE_TYPE on a filesystem.\n"
"    Usually this happens when you ask the cp command to maintain the context "
"of a file when\n"
"    copying between file systems, \"cp -a\" for example.  Not all file "
"contexts should be maintained\n"
"    between the file systems.  For example, a read-only file type like "
"iso9660_t should not be placed\n"
"    on a r/w system.  \"cp -p\" might be a better solution, as this will "
"adopt the default file context\n"
"    for the destination.\n"
"    "
msgstr ""
"\n"
"    SELinux 正阻止 $SOURCE 在文件系统中创建带有 $SOURCE_TYPE 环境 (context) 的文件。\n"
"    这通常是在文件系统间拷贝文件时，要求 cp 命令保留文件的环境属性时发生。\n"
"    比如 \"cp -a\"。在跨文件系统的情况下，并不是所有的文件环境属性都应当保留。\n"
"    比如像 iso9660_t 这样的只读文件类型就不应该放在可读写的文件系统中。\n"
"    \"cp -p\" 会是更好地解决方案，因为这样可以针对目标位置设置默认的文件环境。\n"
"    "

#: ../src/filesystem_associate.py:40
msgid ""
"\n"
"    Use a command like \"cp -p\" to preserve all permissions except SELinux "
"context.\n"
"    "
msgstr "\n"
"    使用命令 \"cp -p\" 保留 SELinux 外的所有 权限。\n"
"    "

#: ../src/filesystem_associate.py:43
msgid ""
"If you believe $SOURCE_BASE_PATH should be allowed to create "
"$TARGET_BASE_PATH files"
msgstr ""

#: ../src/filesystem_associate.py:44
msgid ""
"you need to use a different command. You are not allowed to preserve the "
"SELinux context on the target file system."
msgstr "需要使用不同命令。不允许在目标文件系统中保留 SELinux 上下文。"

#: ../src/filesystem_associate.py:46
msgid ""
"use a command like \"cp -p\" to preserve all permissions except SELinux "
"context."
msgstr "使用类似 \"cp -p\" 的命令保留 SELinux 上下文之外的所有权限。"

#: ../src/httpd_can_sendmail.py:28
msgid "\n"
"    SELinux is preventing the http daemon from sending mail.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 http 守护进程发送电子邮件。\n"
"    "

#: ../src/httpd_can_sendmail.py:32
msgid ""
"\n"
"    SELinux has denied the http daemon from sending mail. An\n"
"    httpd script is trying to connect to a mail port or execute the\n"
"    sendmail command. If you did not setup httpd to sendmail, this could\n"
"    signal an intrusion attempt.\n"
"    "
msgstr ""

#: ../src/httpd_can_sendmail.py:39
msgid ""
"\n"
"    If you want httpd to send mail you need to turn on the\n"
"    $BOOLEAN boolean: \"setsebool -P\n"
"    $BOOLEAN=1\"\n"
"    "
msgstr ""
"\n"
"    如果要允许 httpd 发送电子邮件，则需要开启 $BOOLEAN 布尔值：\n"
"    \"setsebool -P $BOOLEAN=1\"\n"
"    "

#: ../src/httpd_can_sendmail.py:47
msgid "If you want to allow httpd to send mail"
msgstr ""

#: ../src/httpd_can_sendmail.py:48
msgid "you must setup SELinux to allow this"
msgstr "则必须将 SELinux 设定为允许这个"

#: ../src/httpd_unified.py:29
msgid "\n"
"    SELinux prevented httpd $ACCESS access to http files.\n"
"    "
msgstr "\n"
"    SELinux 阻止 httpd $ACCESS 访问 http 文件。\n"
"    "

#: ../src/httpd_unified.py:33
msgid ""
"\n"
"    SELinux prevented httpd $ACCESS access to http files.\n"
"\n"
"    Ordinarily httpd is allowed full access to all files labeled with http "
"file\n"
"    context.  This machine has a tightened security policy with the $BOOLEAN\n"
"    turned off,  This requires explicit labeling of all files.  If a file is\n"
"    a cgi script it needs to be labeled with httpd_TYPE_script_exec_t in "
"order\n"
"    to be executed.  If it is read only content, it needs to be labeled\n"
"    httpd_TYPE_content_t, it is writable content. it needs to be labeled\n"
"    httpd_TYPE_script_rw_t or httpd_TYPE_script_ra_t. You can use the\n"
"    chcon command to change these context.  Please refer to the man page\n"
"    \"man httpd_selinux\" or\n"
"    <a href=\"http://fedora.redhat.com/docs/selinux-apache-fc3\">FAQ</a>\n"
"    \"TYPE\" refers to one of \"sys\", \"user\" or \"staff\" or potentially "
"other\n"
"    script types.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了 httpd $ACCESS 访问 http 文件。\n"
"\n"
"    通常情况下 httpd 可完全访问标记为 http 文件环境的所有文件。\n"
"    此系统严格的安全设置已将该布尔值 $BOOLEAN 关闭。\n"
"    这需要对所有文件进行明确标记。如果该文件\n"
"    是一个 cgi 脚本，为了让其可被执行，需要用 httpd_TYPE_script_exec_t\n"
"    对其进行标记。如果是只读文件，则需标记为 httpd_TYPE_content_t，\n"
"    如果是可写入文件，则需标记为 httpd_TYPE_script_rw_t 或\n"
"    httpd_TYPE_script_ra_t。您可使用\n"
"    chcon 命令修改这些环境。请参考 man 手册页\n"
"    “man httpd_selinux”或\n"
"    <a href=\"http://fedora.redhat.com/docs/selinux-apache-fc3\">常见问题</a>\n"
"    “TYPE”指“sys”，“user”或“staff”之一，也可能是指\n"
"    其它脚本类型。\n"
"    "

#: ../src/httpd_unified.py:50
msgid ""
"\n"
"    Changing the \"$BOOLEAN\" boolean to true will allow this access:\n"
"    \"setsebool -P $BOOLEAN=1\"\n"
"    "
msgstr ""
"\n"
"    将 \"$BOOLEAN\" 布尔值修改为“true”可允许此访问：\n"
"    \"setsebool -P $BOOLEAN=1\"\n"
"    "

#: ../src/httpd_unified.py:57
msgid ""
"If you want to allow httpd to execute cgi scripts and to unify HTTPD "
"handling of all content files."
msgstr ""

#: ../src/httpd_unified.py:58
msgid ""
"you must tell SELinux about this by enabling the 'httpd_unified' and "
"'http_enable_cgi' booleans"
msgstr "您必须通过将 'httpd_unified' 和 'http_enable_cgi' 布尔值设为“true”来告知 SELinux 此情况"

#: ../src/httpd_write_content.py:30
msgid ""
"\n"
"    SELinux prevented httpd $ACCESS access to $TARGET_PATH.\n"
"\n"
"    httpd scripts are not allowed to write to content without explicit\n"
"    labeling of all files.  If $TARGET_PATH is writable content. it needs\n"
"    to be labeled httpd_sys_rw_content_t or if all you need is append you "
"can label it httpd_sys_ra_content_t.   Please refer to 'man httpd_selinux' "
"for more information on setting up httpd and selinux.\n"
"    "
msgstr ""
"\n"
"    SELinux 已阻止 httpd $ACCESS 访问 $TARGET_PATH。\n"
"\n"
"    没有明确标记所有文件前，httpd 脚本不能写入内容。\n"
"    如果 $TARGET_PATH 是可写入文件，需要将其标记为\n"
"    httpd_sys_rw_content_t，或者如果您只想要向其中附加内容，\n"
"    也可以将其标记为 httpd_sys_ra_content_t。    关于设置 httpd 和 selinux 的更多详细信息请参考“man "
"httpd_selinux”。\n"
"    "

#: ../src/httpd_write_content.py:40 ../src/qemu_blk_image.py:45
#: ../src/samba_share.py:45 ../src/swapfile.py:45 ../src/xen_image.py:48
msgid "You need to change the label on '$FIX_TARGET_PATH'"
msgstr "需要更改 '$FIX_TARGET_PATH' 中的标记"

#: ../src/kernel_modules.py:29
msgid ""
"\n"
"    Your system may be seriously compromised! $SOURCE_PATH tried to modify "
"kernel configuration.\n"
"    "
msgstr "\n"
"    系统可能被严重破坏！ $SOURCE_PATH 试图修改内核配置。\n"
"    "

#: ../src/kernel_modules.py:33
msgid ""
"\n"
"    SELinux has prevented $SOURCE from modifying $TARGET.  This denial\n"
"    indicates $SOURCE was trying to modify the way the kernel runs or to\n"
"    actually insert code into the kernel. All applications that need this\n"
"    access should have already had policy written for them.  If a "
"compromised\n"
"    application tries to modify the kernel this AVC will be generated. This "
"is a\n"
"    serious issue. Your system may very well be compromised.\n"
"    "
msgstr ""
"\n"
"    SELinux 已阻止 $SOURCE 修改 $TARGET。该阻\n"
"    止表明 $SOURCE 正尝试修改内核运行方式或实际\n"
"    上在内核中插入代码。所有需要此访问权限的应用 \n"
"    均已获得了各自的策略。如果有被入侵的应用尝试\n"
"    修改内核，本 AVC 就会被触发。此问题很严重。\n"
"    您的系统很有可能已被入侵。\n"
"    "

#: ../src/kernel_modules.py:44 ../src/selinuxpolicy.py:44
msgid ""
"If you do not think $SOURCE_BASE_PATH should try $ACCESS access on "
"$TARGET_BASE_PATH."
msgstr ""

#: ../src/kernel_modules.py:45 ../src/selinuxpolicy.py:45
msgid ""
"you may be under attack by a hacker, since confined applications should not "
"need this access."
msgstr "可能受到黑客攻击，因为受限应用程序不需要此访问。"

#: ../src/leaks.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH access to a leaked $TARGET_PATH file "
"descriptor.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE 访问泄漏的文件描述符 $TARGET_PATH。\n"
"    "

#: ../src/leaks.py:31
msgid ""
"\n"
"    SELinux denied access requested by the $SOURCE command. It looks like "
"this is either a leaked descriptor or $SOURCE output was redirected to a "
"file it is not allowed to access.  Leaks usually can be ignored since "
"SELinux is just closing the leak and reporting the error.  The application "
"does not use the descriptor, so it will run properly.  If this is a "
"redirection, you will not get output in the $TARGET_PATH.  You should "
"generate a bugzilla on selinux-policy, and it will get routed to the "
"appropriate package.  You can safely ignore this avc.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 命令的访问请求。看起来可能是描述符泄露，也可能是将 $SOURCE "
"的输出重定向到了无权访问的文件。泄露一般可忽略，因为 SELinux 会关闭泄露并报告该错误。如果程序不使用描述符，则可正常运行。如果是一个重定向，您在 "
"$TARGET_PATH 中就不会看到输出。您应该可以根据 selinux-policy 生成一个 bugzilla，并被指向适当的软件包。可以忽略此 "
"avc。\n"
"    "

#: ../src/leaks.py:35
msgid ""
"\n"
"    You can generate a local policy module to allow this\n"
"    access - see <a href=\"http://docs.fedoraproject.org/selinux-faq-fc5/"
"#id2961385\">FAQ</a>\n"
"    "
msgstr ""
"\n"
"    可创建本地策略模块来允许该\n"
"    访问 - 请查看 <a href=\"http://docs.fedoraproject.org/selinux-faq-fc5/"
"#id2961385\">常见问题</a>\n"
"    "

#: ../src/leaks.py:42
msgid ""
"If you want to ignore $SOURCE_BASE_PATH trying to $ACCESS access the "
"$TARGET_BASE_PATH $TARGET_CLASS, because you believe it should not need this "
"access."
msgstr ""

#: ../src/leaks.py:43
msgid ""
"You should report this as a bug.  \n"
"You can generate a local policy module to dontaudit this access."
msgstr "应该将此问题作为 bug 报告提交。 \n"
"可创建本地策略模块来要求不审核此访问。"

#: ../src/leaks.py:44
msgid ""
"# ausearch -x $SOURCE_PATH --raw | audit2allow -D -M my-$SOURCE\n"
"# semodule -i my-$SOURCE.pp"
msgstr ""

#: ../src/mmap_zero.py:29
msgid ""
"\n"
"    Your system may be seriously compromised! $SOURCE_PATH attempted to mmap "
"low kernel memory.\n"
"    "
msgstr "\n"
"    您的系统可能被严重破坏！ $SOURCE_PATH 试图 mmap 低内核内存。\n"
"    "

#: ../src/mmap_zero.py:33
msgid ""
"\n"
"    SELinux has denied the $SOURCE the ability to mmap low area of the "
"kernel \n"
"    address space.  The ability to mmap a low area of the address space is \n"
"    configured by /proc/sys/kernel/mmap_min_addr.  Preventing such mappings \n"
"    helps protect against exploiting null deref bugs in the kernel. All \n"
"    applications that need this access should have already had policy "
"written \n"
"    for them.  If a compromised application tries to modify the kernel, this "
"AVC \n"
"    would be generated. This is a serious issue. Your system may very well "
"be \n"
"    compromised.\n"
"    "
msgstr ""

#: ../src/mmap_zero.py:46
msgid ""
"If you do not think $SOURCE_PATH should need to mmap low memory in the "
"kernel."
msgstr ""

#: ../src/mmap_zero.py:47
msgid "you may be under attack by a hacker, this is a very dangerous access."
msgstr "您可能受到黑客攻击，这是一个非常危险的访问。"

#: ../src/mounton.py:29
msgid ""
"\n"
"    SELinux prevented $SOURCE from mounting on the file or directory\n"
"    \"$TARGET_PATH\" (type \"$TARGET_TYPE\").\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了 $SOURCE 挂载文件或者目录\n"
"    \"$TARGET_PATH\" (类型为 \"$TARGET_TYPE\")。\n"
"    "

#: ../src/mounton.py:34
msgid ""
"\n"
"    SELinux prevented $SOURCE from mounting a filesystem on the file\n"
"    or directory \"$TARGET_PATH\" of type \"$TARGET_TYPE\". By default\n"
"    SELinux limits the mounting of filesystems to only some files or\n"
"    directories (those with types that have the mountpoint attribute). The\n"
"    type \"$TARGET_TYPE\" does not have this attribute. You can change the\n"
"    label of the file or directory.\n"
"    "
msgstr ""
"\n"
"    SELinux 已阻止 $SOURCE 在类型为 $TARGET_TYPE 的文件或\n"
"    目录 $TARGET_PATH 上挂载文件系统。SELinux 默认会限制将\n"
"    文件系统只挂载到某些文件或目录（这些文件或目录均具有挂载点属性。）\n"
"    而 $TARGET_TYPE 没有此种属性。可修改对应文件或目录的标记。\n"
"    "

#: ../src/mounton.py:43
msgid ""
"\n"
"    Changing the file_context to mnt_t will allow mount to mount the file "
"system:\n"
"    \"chcon -t mnt_t '$TARGET_PATH'.\"\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"mnt_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    将 file_context 改为 mnt_t 可允许 mount 挂载文件系统：\n"
"    \"chcon -t mnt_t '$TARGET_PATH'。\"\n"
"    还必须更改系统中的默认文件环境文件以便即使在完全重新标记时也可以保留它们。\"semanage fcontext -a -t mnt_t "
"'$FIX_TARGET_PATH'\"\n"
"    "

#: ../src/mounton.py:48
msgid "If you want to allow $SOURCE_BASE_PATH to mount on $TARGET_BASE_PATH."
msgstr ""

#: ../src/mounton.py:49
msgid "you must change the labeling on $TARGET_PATH."
msgstr "则必须在 $TARGET_PATH 中更改标记。"

#: ../src/mozplugger.py:31
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. It is not expected that this "
"access is required by $SOURCE and this access may signal an intrusion "
"attempt. It is also possible that the specific version or configuration of "
"the application is causing it to require additional access.  mozplugger and "
"spice-xpi run applications within mozilla-plugins that require access to the "
"desktop, that the mozilla_plugin lockdown will not allow, so either you need "
"to turn off the mozilla_plugin lockdown or not use these packages.\n"
"    "
msgstr ""
"\n"
"SELinux 拒绝了 $SOURCE 的访问请求。$SOURCE "
"不该需要此访问权限。因此这可能是企图入侵的信号。然而这也可能是应用程序的特定版本或配置导致其需要此额外访问权限。spice-xpi 在需要访问桌面的 "
"mozilla 插件中运行程序，而这是 mozilla_plugin lockdown 所不允许的，因此只能关闭 mozilla_plugin "
"lockdown，或不使用这些软件包。"

#: ../src/mozplugger.py:35
msgid ""
"\n"
"Either remove the mozplugger or spice-xpi package by executing 'yum remove "
"mozplugger spice-xpi' or turn off enforcement of SELinux over the Firefox "
"plugins. setsebool -P unconfined_mozilla_plugin_transition 0\n"
"    "
msgstr ""
"\n"
"可以执行 'yum remove mozplugger spice-xpi' 删除 mozplluger 软件包，或者关闭 Firefox 插件中的 "
"SELinux 强制检查。\n"
"setsebool -P unconfined_mozilla_plugin_transition 0\n"
"\n"
"    "

#: ../src/mozplugger.py:43
msgid "you must turn off SELinux controls on the Firefox plugins."
msgstr "必须关闭 SELinux 对于 FIrefox 插件的控制。"

#: ../src/mozplugger_remove.py:31
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. It is not\n"
"    expected that this access is required by $SOURCE and this access\n"
"    may signal an intrusion attempt. It is also possible that the specific\n"
"    version or configuration of the application is causing it to require\n"
"    additional access.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 的访问请求。这不该是\n"
"    $SOURCE 所需要的访问请求故此这个请求\n"
"    可能代表一个入侵企图。 也可能是特定\n"
"    版本或应用程序的配置导致其需要\n"
"    额外访问。\n"
"    "

#: ../src/mozplugger_remove.py:39
msgid ""
"\n"
"Either remove the mozplluger package by executing 'yum remove mozplugger'\n"
"Or turn off enforcement of SELinux over the Firefox plugins.\n"
"setsebool -P unconfined_mozilla_plugin_transition 0\n"
"    "
msgstr ""
"\n"
"可以执行 'yum remove mozplugger' 移除 mozplluger 软件包， \n"
"后者关闭 Firefox 插件的 SELinux 强制检查。\n"
"setsebool -P unconfined_mozilla_plugin_transition 0\n"
"    "

#: ../src/mozplugger_remove.py:44
msgid ""
"If you want to to continue using SELinux Firefox plugin containment rather "
"then using mozplugger package"
msgstr ""

#: ../src/mozplugger_remove.py:45
msgid "you must remove the mozplugger package."
msgstr "则必须删除 mozplugger 软件包。"

#: ../src/openvpn.py:35
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. $TARGET_PATH may\n"
"    be mislabeled. openvpn is allowed to read content in home directory if "
"it\n"
"    is labeled correctly.\n"
"    "
msgstr ""

#: ../src/openvpn.py:41
msgid ""
"\n"
"    You can restore the default system context to this file by executing the\n"
"    restorecon command.  \n"
"    # restorecon -R /root/.ssh\n"
"    "
msgstr ""

#: ../src/openvpn.py:49
msgid ""
"If you want to mv $TARGET_BASE_PATH to standard location so that "
"$SOURCE_BASE_PATH can have $ACCESS access"
msgstr ""

#: ../src/openvpn.py:51
msgid ""
"If you want to modify the label on $TARGET_BASE_PATH so that "
"$SOURCE_BASE_PATH can have $ACCESS access on it"
msgstr ""

#: ../src/openvpn.py:55
msgid "you must move the cert file to the ~/.cert directory"
msgstr "则必须将证书文件移动到 ~/.cert 目录中"

#: ../src/openvpn.py:57 ../src/sshd_root.py:48
msgid "you must fix the labels."
msgstr "则必须改正这个标签。"

#: ../src/public_content.py:31
msgid ""
"\n"
"    SELinux denied access to $TARGET_PATH requested by $SOURCE.\n"
"    $TARGET_PATH has a context used for sharing by a different program. If "
"you\n"
"    would like to share $TARGET_PATH from $SOURCE also, you need to\n"
"    change its file context to public_content_t.  If you did not intend to\n"
"    allow this access, this could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 请求的对 $TARGET_PATH 的访问。\n"
"    $TARGET_PATH 具有一个用于被不同程序共享的上下文。如果您想\n"
"    让 $SOURCE 也共享 $TARGET_PATH ，您需要将它的文件上下文改\n"
"    为 public_content_t。如果没有打算进行这个访问，这可能是入侵尝试的信号。\n"
"    "

#: ../src/public_content.py:39
msgid ""
"\n"
"    You can alter the file context by executing chcon -t public_content_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"public_content_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    可以执行 executing chcon -t public_content_t '$TARGET_PATH' 更改文件上下文。\n"
"    还必须在系统中更改默认文件上下文文件，以便在完全重新标记后保留它们。\"semanage fcontext -a -t "
"public_content_t '$FIX_TARGET_PATH'\""

#: ../src/public_content.py:50
msgid "If you want to treat $TARGET_BASE_PATH as public content"
msgstr ""

#: ../src/public_content.py:51
msgid ""
"You need to change the label on $TARGET_BASE_PATH to public_content_t or "
"public_content_rw_t."
msgstr "则需要在 $TARGET_BASE_PATH 将标签改为 public_content_t 或 public_content_rw_t。"

#: ../src/qemu_blk_image.py:31
msgid ""
"\n"
"    SELinux denied qemu access to the block device $TARGET_PATH.\n"
"    If this is a virtualization image, it needs to be labeled with a "
"virtualization file context (virt_image_t). You can relabel $TARGET_PATH to "
"be virt_image_t using chcon.  You also need to execute semanage fcontext -a -"
"t virt_image_t '$FIX_TARGET_PATH' to add this\n"
"    new path to the system defaults. If you did not intend to use "
"$TARGET_PATH as a qemu\n"
"    image it could indicate either a bug or an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 qemu 访问 $TARGET_PATH。\n"
"    如果这是一个虚拟化映像，它应当有一个虚拟文件上下文标签（virt_image_t）。可以使用 chcon 将 $TARGET_PATH "
"重新标记为 virt_image_t。还需要执行 semanage fcontext -a -t virt_image_t "
"'$FIX_TARGET_PATH' 将这个新路径添加到系统默认中。\n"
"   如果并未想要使用 $TARGET_PATH 作为 qemu 映像，那么这可能意味着一个 Bug 或是入侵尝试的信号。\n"
"    "

#: ../src/qemu_blk_image.py:38 ../src/qemu_file_image.py:41
msgid ""
"\n"
"    You can alter the file context by executing chcon -t virt_image_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"virt_image_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    可以执行 chcon -t virt_image_t '$TARGET_PATH' 来更改文件上下文。\n"
"    还必须在系统中更改默认文件上下文文件以便在完全重新标记后保留它们。\"semanage fcontext -a -t virt_image_t "
"'$FIX_TARGET_PATH'\""

#: ../src/qemu_blk_image.py:46
msgid ""
"# semanage fcontext -a -t virt_image_t '$FIX_TARGET_PATH'\n"
"# restorecon -v '$FIX_TARGET_PATH'"
msgstr ""
"# semanage fcontext -a -t virt_image_t '$FIX_TARGET_PATH'\n"
"# restorecon -v '$FIX_TARGET_PATH'"

#: ../src/qemu_file_image.py:31
msgid ""
"\n"
"    SELinux denied qemu access to $TARGET_PATH.\n"
"    If this is a virtualization image, it has to have a file context label "
"of\n"
"    virt_image_t. The system is setup to label image files in directory./var/"
"lib/libvirt/images\n"
"    correctly.  We recommend that you copy your image file to /var/lib/"
"libvirt/images.\n"
"    If you really want to have your qemu image files in the current "
"directory, you can relabel $TARGET_PATH to be virt_image_t using chcon.  You "
"also need to execute semanage fcontext -a -t virt_image_t '$FIX_TARGET_PATH' "
"to add this\n"
"    new path to the system defaults. If you did not intend to use "
"$TARGET_PATH as a qemu\n"
"    image it could indicate either a bug or an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 qemu 访问 $TARGET_PATH。\n"
"    如果这是一个虚拟镜像，它应有 virt_image_t 文件环境标记。\n"
"    系统已设置为将目录 ./var/lib/libvirt/images 中的镜像文件标记为 virt_image_t。\n"
"    我们推荐您将镜像文件拷贝至 ./var/lib/libvirt/images\n"
"    如果确实希望将 qemu 镜像保存在当前目录中，则可以使用 chcon 将 $TARGET_PATH 重新标记为 "
"virt_image_t。还需要执行 semanage fcontext -a -t virt_image_t '$FIX_TARGET_PATH' "
"将此新路径添加到系统\n"
"    默认配置中。如果没有打算将 $TARGET_PATH 用作 qemu 镜像，那么这可能是个 bug，或是尝试入侵的信号。\n"
"    "

#: ../src/qemu_file_image.py:48
msgid "If $TARGET_BASE_PATH is a virtualization target"
msgstr ""

#: ../src/restorecon.py:57
msgid ""
"\n"
"    You can restore the default system context to this file by executing the\n"
"    restorecon command.  restorecon '$TARGET_PATH', if this file is a "
"directory,\n"
"    you can recursively restore using restorecon -R '$TARGET_PATH'.\n"
"    "
msgstr ""
"\n"
"    可以执行 restorecon 命令恢复此文件的默认系统环境。\n"
"    restorecon '$TARGET_PATH'，如果该文件是一个目录，\n"
"    可以使用 restorecon -R '$TARGET_PATH' 进行递归恢复。"

#: ../src/restorecon.py:64
#, python-format
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. $TARGET_PATH may\n"
"    be mislabeled.  $TARGET_PATH default SELinux type is\n"
"    <B>%s</B>, but its current type is <B>$TARGET_TYPE</B>. Changing\n"
"    this file back to the default type may fix your problem.\n"
"    <p>\n"
"    File contexts can be assigned to a file in the following ways.\n"
"    <ul>\n"
"        <li>Files created in a directory receive the file context of the "
"parent directory by default.\n"
"        <li>The SELinux policy might override the default label inherited "
"from the parent directory by\n"
"            specifying a process running in context A which creates a file "
"in a directory labeled B\n"
"            will instead create the file with label C. An example of this "
"would be the dhcp client running\n"
"            with the dhclient_t type and creating a file in the directory /"
"etc. This file would normally\n"
"            receive the etc_t type due to parental inheritance but instead "
"the file\n"
"            is labeled with the net_conf_t type because the SELinux policy "
"specifies this.\n"
"        <li>Users can change the file context on a file using tools such as "
"chcon, or restorecon.\n"
"    </ul>\n"
"    This file could have been mislabeled either by user error, or if an "
"normally confined application\n"
"    was run under the wrong domain.\n"
"    <p>\n"
"    However, this might also indicate a bug in SELinux because the file "
"should not have been labeled\n"
"    with this type.\n"
"    <p>\n"
"    If you believe this is a bug, please file a bug report against this "
"package.\n"
"    "
msgstr ""

#: ../src/restorecon.py:90
#, python-format
msgid ""
"If you want to fix the label. \n"
"$TARGET_PATH default label should be %s."
msgstr ""

#: ../src/restorecon.py:96
msgid ""
"you can run restorecon. The access attempt may have been stopped due to "
"insufficient permissions to access a parent directory in which case try to "
"change the following command accordingly."
msgstr ""

#: ../src/restorecon.py:105 ../src/restorecon_source.py:73
msgid "Restore\n"
"Context"
msgstr "Restore\n"
"Context"

#: ../src/restorecon_source.py:39
msgid ""
"\n"
"    You can restore the default system context to this file by executing the\n"
"    restorecon command.  restorecon '$SOURCE_PATH'.\n"
"    "
msgstr "\n"
"    可使用 resotrecon 命令\n"
"恢复该文件的默认文件环境。restorecon '$SOURCE_PATH'。\n"
"    "

#: ../src/restorecon_source.py:45
#, python-format
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. $SOURCE_PATH may\n"
"    be mislabeled.  $SOURCE_PATH default SELinux type is\n"
"    <B>%s</B>, but its current type is <B>$SOURCE_TYPE</B>. Changing\n"
"    this file back to the default type may fix your problem.\n"
"    <p>\n"
"    This file could have been mislabeled either by user error, or if an "
"normally confined application\n"
"    was run under the wrong domain.\n"
"    <p>\n"
"    However, this might also indicate a bug in SELinux because the file "
"should not have been labeled\n"
"    with this type.\n"
"    <p>\n"
"    If you believe this is a bug, please file a bug report against this "
"package.\n"
"    "
msgstr ""

#: ../src/restorecon_source.py:60
#, python-format
msgid ""
"If you want to fix the label. \n"
"$SOURCE_PATH default label should be %s."
msgstr ""

#: ../src/restorecon_source.py:65
msgid "you can run restorecon."
msgstr "可以运行 restorecon。"

#: ../src/rsync_data.py:31
msgid ""
"\n"
"    SELinux denied RSYNC access to $TARGET_PATH.\n"
"    If this is an RSYNC repository, it has to have a file context label of\n"
"    rsync_data_t. If you did not intend to use $TARGET_PATH as an RSYNC "
"repository,\n"
"    this message could indicate either a bug or an intrusion attempt.\n"
"    "
msgstr ""

#: ../src/rsync_data.py:38
msgid ""
"\n"
"    You can alter the file context by executing chcon -R -t rsync_data_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"rsync_data_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    可通过执行 chcon -R -t rsync_data_t '$TARGET_PATH' 更改文件环境。\n"
"    还必须修改系统的默认文件环境文件以便即使在完全重新标记后，仍能保留它们。\"semanage fcontext -a -t "
"rsync_data_t '$FIX_TARGET_PATH'\"\n"
"    "

#: ../src/rsync_data.py:45
msgid "If $TARGET_BASE_PATH should be shared via the RSYNC daemon"
msgstr ""

#: ../src/rsync_data.py:46
msgid "You need to change the label on $TARGET_BASE_PATH"
msgstr "需要修改 $TARGET_BASE_PATH 的标记"

#: ../src/samba_share.py:27
msgid ""
"\n"
"    SELinux is preventing Samba ($SOURCE_PATH) \"$ACCESS\" access to "
"$TARGET_PATH.\n"
"    "
msgstr ""
"\n"
"    SELinux 正在阻止 Samba ($SOURCE_PATH) \"$ACCESS\" 访问 $TARGET_PATH。\n"
"    "

#: ../src/samba_share.py:31
msgid ""
"\n"
"    SELinux denied samba access to $TARGET_PATH.\n"
"    If you want to share this directory with samba it has to have a file "
"context label of\n"
"    samba_share_t. If you did not intend to use $TARGET_PATH as a samba "
"repository,\n"
"    this message could indicate either a bug or an intrusion attempt.\n"
"    Please refer to 'man samba_selinux' for more information on setting up "
"Samba and SELinux.\n"
"    "
msgstr ""

#: ../src/samba_share.py:39
msgid ""
"\n"
"    You can alter the file context by executing chcon -R -t samba_share_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"samba_share_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    可以通过执行 chcon -R -t samba_share_t '$TARGET_PATH' 更改文件上下文。\n"
"    还必须修改系统默认文件环境文件以便即使在完全重新标记后，仍可以保留它们。\"semanage fcontext -a -t "
"samba_share_t '$FIX_TARGET_PATH'\""

#: ../src/samba_share.py:53
#, python-format
msgid ""
"# semanage fcontext -a -t samba_share_t '$FIX_TARGET_PATH%s'\n"
"# restorecon %s -v '$FIX_TARGET_PATH'"
msgstr ""
"# semanage fcontext -a -t samba_share_t '$FIX_TARGET_PATH%s'\n"
"# restorecon %s -v '$FIX_TARGET_PATH'"

#: ../src/sandbox_connect.py:33
msgid ""
"\n"
"    SELinux has denied $SOURCE from connecting to a network port "
"$PORT_NUMBER within a sandbox.\n"
"    If $SOURCE should be allowed to connect on $PORT_NUMBER, you need to use "
"a different sandbox type like sandbox_web_t or sandbox_net_t.  \n"
"    # sandbox -X -t sandbox_net_t $SOURCE\n"
"    \n"
"\n"
"If $SOURCE is not supposed\n"
"    to connect to $PORT_NUMBER, this could signal an intrusion attempt.\n"
"    "
msgstr ""

#: ../src/sandbox_connect.py:41
msgid ""
"\n"
"    If you want to allow $SOURCE to connect to $PORT_NUMBER, you can execute "
"\n"
"\n"
"    # sandbox -X -t sandbox_net_t $SOURCE\n"
"    "
msgstr ""
"\n"
"   如果要允许 $SOURCE 连接到 $PORT_NUMBER 端口，您可以执行\n"
"\n"
"    # sandbox -X -t sandbox_net_t $SOURCE\n"
"    "

#: ../src/sandbox_connect.py:49
msgid ""
"you need to modify the sandbox type. sandbox_web_t or sandbox_net_t.\n"
"For example:\n"
"sandbox -X -t sandbox_net_t $SOURCE_PATH\n"
"Please read 'sandbox' man page for more details.\n"
msgstr ""
"需要修改沙盒类型。sandbox_web_t 或 sandbox_net_t。\n"
"例如：\n"
"sandbox -X -t sandbox_net_t $SOURCE_PATH\n"
"详细信息请阅读 sandbox man 手册页。\n"

#: ../src/selinuxpolicy.py:29
msgid "\n"
"    Your system may be seriously compromised!\n"
"    "
msgstr "\n"
"    您的系统可能被严重入侵！\n"
"    "

#: ../src/selinuxpolicy.py:33
msgid ""
"\n"
"    SELinux has prevented $SOURCE from modifying $TARGET.  This denial\n"
"    indicates $SOURCE was trying to modify the selinux policy configuration.\n"
"    All applications that need this access should have already had policy\n"
"    written for them.  If a compromised application tries to modify the "
"SELinux\n"
"    policy this AVC will be generated. This is a serious issue. Your system\n"
"    may very well be compromised.\n"
"    "
msgstr ""
"\n"
"    SELinux 已阻止 $SOURCE 修改 $TARGET。该阻止措施表明\n"
"    $SOURCE 正尝试修改 selinux 策略配置。\n"
"    所有需要此访问权限的应用程序均有各自的策略。\n"
"    如果有被入侵的应用尝试修改 SELinux\n"
"    策略，就会触发这个 AVC。这个一个严重问题。\n"
"    您的系统很有可能已被破坏。\n"
"    \n"
"    "

#: ../src/setenforce.py:27
msgid "If you did not directly cause this AVC through testing."
msgstr ""

#: ../src/setenforce.py:28
msgid "if you think that you might have been hacked"
msgstr "如果您认为已被攻击，"

#: ../src/setenforce.py:32
msgid ""
"\n"
"    Your system may be seriously compromised! $SOURCE_PATH tried to modify "
"SELinux enforcement.\n"
"    "
msgstr "\n"
"    那么您的系统可能被严重破坏！$SOURCE_PATH 曾尝试修改 SELinux enforcement.\n"
"    "

#: ../src/setenforce.py:36
msgid ""
"\n"
"    SELinux has prevented $SOURCE from writing to a file under /sys/fs/"
"selinux.\n"
"    Files under /sys/fs/selinux control the way SELinux is configured.\n"
"    All programs that need to write to files under /sys/fs/selinux should "
"have already had policy\n"
"    written for them. If a compromised application tries to turn off SELinux\n"
"    this AVC will be generated. This is a serious issue. Your system may "
"very\n"
"    well be compromised.\n"
"    "
msgstr ""

#: ../src/setenforce.py:48
msgid "If you believe $SOURCE_PATH tried to disable SELinux."
msgstr ""

#: ../src/setenforce.py:49
msgid ""
"you may be under attack by a hacker, since confined applications should "
"never need this access."
msgstr "可能受到黑客攻击，因为限定程序从不需要这个访问。"

#: ../src/sshd_root.py:36
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. $TARGET_PATH may\n"
"    be mislabeled. sshd is allowed to read content in /root/.ssh directory "
"if it\n"
"    is labeled correctly.\n"
"    "
msgstr ""

#: ../src/sshd_root.py:42
msgid ""
"\n"
"    You can restore the default system context to this file by executing the\n"
"    restorecon command.\n"
"    # restorecon -R /root/.ssh\n"
"    "
msgstr ""

#: ../src/sshd_root.py:55
msgid "Restore Context"
msgstr "恢复上下文"

#: ../src/swapfile.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH \"$ACCESS\" to $TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH \"$ACCESS\"  $TARGET_PATH。\n"
"    "

#: ../src/swapfile.py:31
msgid ""
"\n"
"    SELinux denied $SOURCE access to $TARGET_PATH.\n"
"    If this is a swapfile, it has to have a file context label of\n"
"    swapfile_t. If you did not intend to use\n"
"    $TARGET_PATH as a swapfile, this message could indicate either a bug or "
"an intrusion attempt.\n"
"    "
msgstr ""

#: ../src/swapfile.py:38
msgid ""
"\n"
"    You can alter the file context by executing chcon -t swapfile_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"swapfile_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    可以执行 executing chcon -t swapfile_t '$TARGET_PATH' 更改文件上下文。\n"
"    还必须在系统中更改默认文件上下文文件以便在完全重新标记后保留它们。\"semanage fcontext -a -t swapfile_t "
"'$FIX_TARGET_PATH'\""

#: ../src/sys_module.py:28
msgid ""
"If you do not believe your $SOURCE_PATH should be modifying the kernel, by "
"loading kernel modules"
msgstr ""

#: ../src/sys_module.py:29
msgid "You might have been hacked."
msgstr "您肯定被攻击了。"

#: ../src/sys_module.py:33
msgid ""
"\n"
"    Your system may be seriously compromised! $SOURCE_PATH tried to load a "
"kernel module.\n"
"    "
msgstr "\n"
"    您的系统可能被严重破坏！ $SOURCE_PATH试图装载一个内核模块。\n"
"    "

#: ../src/sys_module.py:37
msgid ""
"\n"
"    SELinux has prevented $SOURCE from loading a kernel module.\n"
"    All confined programs that need to load kernel modules should have "
"already had policy\n"
"    written for them. If a compromised application\n"
"    tries to modify the kernel this AVC will be generated. This is a serious\n"
"    issue. Your system may very well be compromised.\n"
"    "
msgstr ""
"\n"
"    SELinux 已阻止 $SOURCE 加载一个内核模块。\n"
"    所有需加载内核模块的受限程序应该都已拥有了\n"
"    各自的策略。如果有被入侵的应用程序尝试修改\n"
"    内核，此 AVC 就会产生。此问题很严重。\n"
"    您的系统很有可能已被破坏。\n"
"    "

#: ../src/sys_module.py:46
msgid ""
"If you do not believe that $SOURCE_PATH should be attempting to modify the "
"kernel by loading a kernel module."
msgstr ""

#: ../src/sys_module.py:47
msgid "A process might be attempting to hack into your system."
msgstr "应该是某个进程正在尝试入侵您的系统。"

#: ../src/sys_resource.py:28
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH the \"sys_resource\" capability.\n"
"    "
msgstr "\n"
"    SELinux 将防止 $SOURCE_PATH 的 \"sys_resource\" 功能。\n"
"    "

#: ../src/sys_resource.py:32
msgid ""
"\n"
"    Confined domains should not require \"sys_resource\". This usually means "
"that     your system is running out some system resource like disk space, "
"memory, quota etc. Please clear up the disk and this\n"
"    AVC message should go away. If this AVC continues after you clear up the "
"disk space, please report this as a bug.\n"
"    "
msgstr ""
"\n"
"    限制域不应该需要“sys_resource”。这通常意味着您的某些系统资源已用尽，比如磁盘空间、内存、配额等等。请清理该磁盘，\n"
"    此 AVC 信息就会消失。如果在清理磁盘后此 AVC 仍然出现，请将其作为 bug 报告提交。\n"
"    "

#: ../src/sys_resource.py:39
msgid ""
"If you do not want processes to require capabilities to use up all the "
"system resources on your system;"
msgstr ""

#: ../src/sys_resource.py:40
msgid ""
"you need to diagnose why your system is running out of system resources and "
"fix the problem.\n"
"\n"
"According to /usr/include/linux/capability.h, sys_resource is required to:\n"
"\n"
"/* Override resource limits. Set resource limits. */\n"
"/* Override quota limits. */\n"
"/* Override reserved space on ext2 filesystem */\n"
"/* Modify data journaling mode on ext3 filesystem (uses journaling\n"
"   resources) */\n"
"/* NOTE: ext2 honors fsuid when checking for resource overrides, so\n"
"   you can override using fsuid too */\n"
"/* Override size restrictions on IPC message queues */\n"
"/* Allow more than 64hz interrupts from the real-time clock */\n"
"/* Override max number of consoles on console allocation */\n"
"/* Override max number of keymaps */\n"
msgstr ""

#: ../src/vbetool.py:30
msgid ""
"\n"
"    SELinux has prevented vbetool from performing an unsafe memory operation."
"\n"
"    "
msgstr "\n"
"    SELinux 阻止了 vbetool 执行一项不安全的内存操作。\n"
"    "

#: ../src/vbetool.py:34
msgid ""
"\n"
"SELinux denied an operation requested by $SOURCE, a program used\n"
"to alter video hardware state.  This program is known to use\n"
"an unsafe operation on system memory but so are a number of\n"
"malware/exploit programs which masquerade as vbetool.  This tool is used to\n"
"reset video state when a machine resumes from a suspend.  If your machine\n"
"is not resuming properly your only choice is to allow this\n"
"operation and reduce your system security against such malware.\n"
"\n"
"    "
msgstr ""
"\n"
"SELinux 拒绝了一项由 $SOURCE 发起的操作，该程序用于更改\n"
"视频硬件的状态。该程序已知会在系统内存上进行不安全操作，\n"
"因此有很多恶意/溢出程序伪会装成 vbetool。该工具用于在系统\n"
"从挂起状态恢复时重设视频硬件的状态。如果系统无法正常\n"
"从挂起状态恢复，只能选择允许操作。此操作将降低系统针对\n"
"此类恶意程序的安全防御能力。\n"
"\n"
"    "

#: ../src/vbetool.py:45 ../src/wine.py:56
msgid ""
"\n"
"If you decide to continue to run the program in question you will need\n"
"to allow this operation.  This can be done on the command line by\n"
"executing:\n"
"\n"
"# setsebool -P mmap_low_allowed 1\n"
msgstr ""
"\n"
"如果决定继续运行有问题的程序，则必须允许此操作。可在命令行长执行以下命令达到此目的：\n"
"\n"
"# setsebool -P mmap_low_allowed 1\n"

#: ../src/vbetool.py:55
msgid ""
"If you want to ignore this AVC because it is dangerous and your machine "
"seems to be working correctly."
msgstr ""

#: ../src/vbetool.py:56
msgid ""
"you must tell SELinux about this by enabling the vbetool_mmap_zero_ignore "
"boolean."
msgstr "则必须启用 vbetool_mmap_zero_ignore 布尔告知 SELinux 这个情况。"

#: ../src/vbetool.py:62 ../src/wine.py:73
msgid "Turn off memory protection"
msgstr "关闭内存保护"

#: ../src/wine.py:31
msgid ""
"\n"
"    SELinux has prevented wine from performing an unsafe memory operation.\n"
"    "
msgstr "\n"
"    SELinux 阻止了 wine 执行一项不安全的内存操作。\n"
"    "

#: ../src/wine.py:35
msgid ""
"\n"
"SELinux denied an operation requested by wine-preloader, a program used\n"
"to run Windows applications under Linux.  This program is known to use\n"
"an unsafe operation on system memory but so are a number of\n"
"malware/exploit programs which masquerade as wine.  If you were\n"
"attempting to run a Windows program your only choices are to allow this\n"
"operation and reduce your system security against such malware or to\n"
"refrain from running Windows applications under Linux.  If you were not\n"
"attempting to run a Windows application this indicates you are likely\n"
"being attacked by some for of malware or program trying to exploit your\n"
"system for nefarious purposes.\n"
"\n"
"Please refer to\n"
"\n"
"http://wiki.winehq.org/PreloaderPageZeroProblem\n"
"\n"
"Which outlines the other problems wine encounters due to its unsafe use\n"
"of memory and solutions to those problems.\n"
"\n"
"    "
msgstr ""
"\n"
"SELinux 阻止了一个由 wine-preloader 请求的操作，该程序用于\n"
"在 Linux 系统中运行 Windows 程序。已知此程序会在系统内存中\n"
"进行不安全操作，因此也有大量的恶意或利用程序伪装成 wine。\n"
"如果要运行 Windows 程序，那么唯一的选择就是允许此操作。\n"
"这将降低系统对恶意程序的安全防护。或者坚持不在 Linux 系统下\n"
"运行 Windows 程序。如果没有尝试运行 Windows 程序，这说明\n"
"您的系统很有可能已被某些恶意或试图利用您系统实现恶意目的程序\n"
"攻击。\n"
"\n"
"请参考\n"
"\n"
"http://wiki.winehq.org/PreloaderPageZeroProblem\n"
"\n"
"该页面概述了因 wine 自身对内存的不安全使用而造成的其他问题\n"
"以及这些问题的解决办法。\n"
"\n"
"    "

#: ../src/wine.py:66
msgid ""
"If you want to ignore this AVC because it is dangerous and your wine "
"applications are working correctly."
msgstr ""

#: ../src/wine.py:67
msgid ""
"you must tell SELinux about this by enabling the wine_mmap_zero_ignore "
"boolean."
msgstr "则必须通过启用 wine_mmap_zero_ignore 告知 SELinux 这个情况。"

#: ../src/xen_image.py:27
msgid ""
"\n"
"    SELinux is preventing xen ($SOURCE_PATH) \"$ACCESS\" access to "
"$TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止xen ($SOURCE_PATH) \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    "

#: ../src/xen_image.py:31
msgid ""
"\n"
"    SELinux denied xen access to $TARGET_PATH.\n"
"    If this is a XEN image, it has to have a file context label of\n"
"    xen_image_t. The system is setup to label image files in directory /var/"
"lib/xen/images\n"
"    correctly.  We recommend that you copy your image file to /var/lib/xen/"
"images.\n"
"    If you really want to have your xen image files in the current "
"directory, you can relabel $TARGET_PATH to be xen_image_t using chcon.  You "
"also need to execute semanage fcontext -a -t xen_image_t '$FIX_TARGET_PATH' "
"to add this\n"
"    new path to the system defaults. If you did not intend to use "
"$TARGET_PATH as a xen\n"
"    image it could indicate either a bug or an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 xen 访问 $TARGET_PATH。\n"
"    如果这是一个 XEN 映像，它应当有一个 xen_image_t 文件上下文标签。\n"
"    已经将该系统设置为在目录 /var/lib/xen/images 中标记映像文件\n"
"    如果确实希望将 xen 映像保存在当前目录下，则可以使用 chcon 将 $TARGET_PATH 重新标记为 "
"xen_image_t。还需要执行 semanage fcontext -a -t xen_image_t '$FIX_TARGET_PATH' "
"将这个新路径添加到系统默认中。如果没想要使用 $TARGET_PATH 作为 xen 映像，那么这可能意味着一个 Bug 或是入侵尝试的信号。\n"
"    "

#: ../src/xen_image.py:41
msgid ""
"\n"
"    You can alter the file context by executing chcon -t xen_image_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"xen_image_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    您可以执行 chcon -t xen_image_t '$TARGET_PATH' 来更改文件环境。\n"
"    您还必须修改系统默认的文件环境文件以便即使在完全重新标记后，仍能保留它们。\"semanage fcontext -a -t "
"xen_image_t '$FIX_TARGET_PATH'\"\n"
"    "
